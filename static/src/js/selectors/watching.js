import countBy from 'lodash/countBy';
import filter from 'lodash/filter';
import flatten from 'lodash/flatten';
import forEach from 'lodash/forEach';
import intersection from 'lodash/intersection';
import map from 'lodash/map';
import merge from 'lodash/merge';
import reduce from 'lodash/reduce';
import sortBy from 'lodash/sortBy';
import union from 'lodash/union';
import { compileRosterDetails, compileVillianLineup, myCurrentLineupsSelector } from './current-lineups';
import { createSelector } from 'reselect';
import { dateNow } from '../lib/utils';
import { entriesContestLineupSelector } from './entries';
import { entriesHaveRelatedInfoSelector } from './entries';
import { GAME_DURATIONS } from '../actions/sports';
import { gamesTimeRemainingSelector } from './sports';
import { liveContestsSelector } from './live-contests';


// used to let components know that the selector is waiting on actions
export const isLoadingObj = { isLoading: true };

const currentLineupsSelector = (state) => state.currentLineups.items;
const liveDraftGroupsSelector = (state) => state.liveDraftGroups;
const onlyLiveContestsSelector = (state) => state.liveContests;
const watchingSelector = (state) => state.watching;

/**
 * Helper method for calcRelevantItems, which combines arrays of objects for games and players
 * @param  {Object}   items    Former games and players
 * @param  {array}    roster   The list of new players whose games they're in we add
 * @return {object}            Combined games and players
 */
const addToRelevantItems = (roster, items = { games: [], players: [] }) => ({
  games: union(items.games, map(roster, (player) => player.gameSRID)),
  players: union(items.players, map(roster, (player) => player.srid)),
});

/**
 * Take the current contest and return two lists, one with all players by ownership, and the other the top 8 not owned
 * by me.
 * @param  {object} contest  Contest object
 * @param  {string} sport    Which sport the contest is for, used to determine default roster length
 * @param  {list}   myRoster Roster to filter out players with
 * @return {object}          All players and top 8 players not in my lineup
 */
const calcContestPlayersOwnership = (contestLineups, draftGroup, sport, gamesTimeRemaining, myRoster) => {
  const numOfPlayers = GAME_DURATIONS[sport].players;

  const lineups = filter(contestLineups, (lineup) => lineup.roster[0] !== 0);
  const allPlayers = flatten(map(lineups, (lineup) => lineup.roster));
  const counts = countBy(allPlayers, (playerId) => playerId);

  // all
  const mappedPlayers = map(counts, (ownershipCount, playerId) => ({
    ownershipCount,
    playerId,
    ownershipPercent: parseInt(ownershipCount / allPlayers.length * 100, 10),
  }));
  const allPlayersByCounts = sortBy(mappedPlayers, (playerWithCount) => playerWithCount.ownershipCount).reverse();

  // filter to players not owned by me
  const nonOwnedByMe = filter(allPlayersByCounts, (player) => myRoster.indexOf(player.playerId) === -1);
  let top8 = sortBy(nonOwnedByMe, (playerWithCount) => playerWithCount.ownershipCount);

  // return top 8 not owned by me, if there are 8 to use, otherwise return all
  if (top8.length > numOfPlayers) {
    top8 = top8.slice(0, numOfPlayers);
  } else {
    top8 = allPlayersByCounts.slice(0, numOfPlayers);
  }
  top8 = map(top8, (p) => p.playerId);

  // return players with their stats
  const allWithStats = compileRosterDetails(allPlayers, draftGroup, gamesTimeRemaining, []);

  // combine counts with data
  const all = map(allPlayersByCounts,
    (playerWithCount) => merge(
      playerWithCount,
      allWithStats[playerWithCount.playerId]
    )
  );

  const allByPlayerId = {};
  forEach(mappedPlayers, (playerWithCount) => {
    allByPlayerId[playerWithCount.playerId] = playerWithCount.ownershipPercent;
  });

  return {
    all,
    top8,
    allByPlayerId,
  };
};

/**
 * Loop through all contests a lineup is in and return pertinent information on them if they're live
 * @param  {integer} lineup        Lineup
 * @param  {object} lineupContests List of contests the lineup is in to loop through
 * @param  {object} contestsStats  Contest stats generated by the contest selector
 * @param  {object} liveContests   List of live contests from the server
 * @return {object}                List of contests with new stats
 */
const calcEntryContestStats = (lineup, lineupContests, liveContests) => {
  if (lineup.hasOwnProperty('id') === false) return {};

  const stats = {};

  // loop through each of the lineup's entered contests
  forEach(lineupContests, (contestId) => {
    // Make sure we have lineups.
    if (liveContests.hasOwnProperty(contestId) === false || !liveContests[contestId].hasOwnProperty('lineups')) return;

    const liveContest = liveContests[contestId];
    const entryStats = liveContest.lineups[lineup.id];

    // if stats exist (aka the lineup has started playing), then modify the given contest stats with some additional
    // information, such as our entry's rank and position, since we don't need to calculate for everyone yet
    if (entryStats && liveContest) {
      stats[contestId] = merge({}, liveContest, {
        myPercentagePosition: (entryStats.rank - 1) / liveContest.entriesCount * 100,
        myEntryRank: entryStats.rank,
        potentialWinnings: entryStats.potentialWinnings,
      });
    }
  });

  return stats;
};

/**
 * Helper method to find players that exist in both lineups a user is watching
 * @param  {object} myLineup       Lineup object
 * @param  {object} opponentLineup Lineup Object
 * @return {array}                 SRID of players in both lineups
 */
const calcPlayersInBothLineups = (myLineup, opponentLineup) =>
  intersection(
    myLineup.rosterBySRID || [],
    opponentLineup.rosterBySRID || []
  );

/**
 * Helper method to determin potential winnings for a lineup in a contest
 * @param  {integer} lineupId        Lineup ID
 * @param  {object}  contestLineups  Contest with lineups
 * @param  {integer} entriesCount    How many entries in the contest
 * @return {object}                  Potential winnings in amount and percent
 */
const calcPotentialContestStats = (lineup, contest, entriesCount = 0) => {
  const contestLineup = contest.lineups[lineup.id];
  const rank = contestLineup.rank || 0;

  return {
    amount: contestLineup.potentialWinnings,
    percent: rank / entriesCount * 100,
    rank,
  };
};

/**
 * Helper method to calculate relevant games and players
 * @param  {object} myLineup       My lineup stats
 * @param  {object} opponentLineup Opponent lineup stats
 * @return {object}                Same result as updateRelevantItems, object with games and players
 */
const calcRelevantItems = (myLineup, opponentLineup) =>
  addToRelevantItems(
    opponentLineup.rosterDetails || {},
    addToRelevantItems(myLineup.rosterDetails || {})
  );

/**
 * Shortcut method to loop through all lineup entries and their associated contests to sum potential earnings
 * @param  {object} entries       List of entries the lineup is in
 * @param  {object} contestsStats List of contests with their associated stats
 * @return {number}               Total potential earnings for the lineup
 */
export const calcTotalPotentialEarnings = (entries, contestsStats) =>
  reduce(entries, (sum, entry) => {
    // Make sure we have entries.
    if (contestsStats.hasOwnProperty(entry.contest)) {
      const contestLineups = contestsStats[entry.contest].lineups || {};

      if (contestLineups.hasOwnProperty(entry.lineup)) {
        return sum + contestsStats[entry.contest].lineups[entry.lineup].potentialWinnings;
      }
    }

    return sum;
  },
0);

// exported simply to test
export const watchingMyLineupSelector = createSelector([
  watchingSelector,
  myCurrentLineupsSelector,
  currentLineupsSelector,
  liveContestsSelector,
  entriesContestLineupSelector,
], (
  watching,
  myCurrentLineups,
  currentLineups,
  liveContests,
  entries
) => {
  if (watching.myLineupId === null) return isLoadingObj;

  const lineup = myCurrentLineups[watching.myLineupId];
  // don't return anything until we have the lineup stats
  if (!lineup) return isLoadingObj;

  const originalLineup = currentLineups[lineup.id];
  // don't return anything until we have the original lineup, for contests stats
  if (!originalLineup) return isLoadingObj;

  return merge({}, lineup, {
    contestsStats: calcEntryContestStats(lineup, originalLineup.contests, liveContests),
    isLoading: false,
    totalBuyin: reduce(lineup.contests || {}, (sum, id) => sum + liveContests[id].buyin, 0),
    potentialWinnings: calcTotalPotentialEarnings(entries, liveContests),
  });
});

// exported simply to test
export const watchingContestSelector = createSelector([
  watchingSelector,
  watchingMyLineupSelector,
  liveContestsSelector,
  onlyLiveContestsSelector,
  liveDraftGroupsSelector,
  gamesTimeRemainingSelector,
], (
  watching,
  myLineup,
  liveContests,
  onlyLiveContests,
  liveDraftGroups,
  gamesTimeRemaining
) => {
  // don't run if we don't have a contest
  if (watching.contestId === null) return {};

  const contest = liveContests[watching.contestId];
  const originalContest = onlyLiveContests[watching.contestId] || {};

  // if still loading
  if (myLineup.isLoading || !contest || contest.hasOwnProperty('lineups') === false) return isLoadingObj;

  const draftGroup = liveDraftGroups[myLineup.draftGroupId];
  const sport = watching.sport;
  const playersOwnership = calcContestPlayersOwnership(
    contest.lineups,
    draftGroup,
    sport,
    gamesTimeRemaining,
    myLineup.roster
  );

  // if villian watching, add to contest lineups
  if (watching.opponentLineupId === 1) {
    contest.lineups[1] = compileVillianLineup(
      playersOwnership.top8,
      draftGroup,
      gamesTimeRemaining
    );
  }

  return merge({}, contest, {
    isLoading: false,
    lineupsUsernames: originalContest.lineupsUsernames || {},
    potentialWinnings: calcPotentialContestStats(myLineup, contest, 1),
    playersOwnership,
  });
});

// exported simply to test
export const watchingOpponentLineupSelector = createSelector(
  [watchingSelector, watchingContestSelector],
  (watching, contest) => {
    if (watching.opponentLineupId === null) return {};
    if (contest.isLoading) return isLoadingObj;

    const lineup = contest.lineups[watching.opponentLineupId];
    return merge({}, lineup, {
      potentialWinnings: calcPotentialContestStats(lineup, contest),
    });
  }
);

export const watchingDraftGroupTimingSelector = createSelector(
  [watchingSelector, watchingMyLineupSelector, liveDraftGroupsSelector],
  (watching, myLineup, liveDraftGroups) => {
    const whenBooleans = {
      ended: false,
      started: true,
    };

    if (watching.draftGroupId && liveDraftGroups.hasOwnProperty(watching.draftGroupId)) {
      const draftGroup = liveDraftGroups[watching.draftGroupId];

      if (draftGroup.closed !== null && draftGroup.closed < dateNow()) whenBooleans.ended = true;
      if (draftGroup.start > dateNow()) whenBooleans.started = false;
    }

    return whenBooleans;
  }
);

export const relevantGamesPlayersSelector = createSelector(
  [watchingMyLineupSelector, watchingContestSelector, watchingOpponentLineupSelector, entriesHaveRelatedInfoSelector],
  (myLineup, contest, opponentLineup, haveRelatedInfo) => {
    // return loading message if it is not done
    if (haveRelatedInfo === false || myLineup.isLoading || contest.isLoading || opponentLineup.isLoading) {
      return isLoadingObj;
    }

    return {
      isLoading: false,
      playersInBothLineups: calcPlayersInBothLineups(myLineup, opponentLineup),
      relevantItems: calcRelevantItems(myLineup, opponentLineup),
    };
  }
);
