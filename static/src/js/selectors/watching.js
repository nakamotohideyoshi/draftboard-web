import countBy from 'lodash/countBy';
import filter from 'lodash/filter';
import flatten from 'lodash/flatten';
import forEach from 'lodash/forEach';
import intersection from 'lodash/intersection';
import map from 'lodash/map';
import merge from 'lodash/merge';
import reduce from 'lodash/reduce';
import sortBy from 'lodash/sortBy';
import union from 'lodash/union';
import { compileRosterDetails, compileVillianLineup, myCurrentLineupsSelector } from './current-lineups';
import { createSelector } from 'reselect';
import { dateNow } from '../lib/utils';
import { lineupsHaveRelatedInfoSelector } from './current-lineups';
import { gamesTimeRemainingSelector } from './sports';
import { liveContestsSelector } from './live-contests';


// used to let components know that the selector is waiting on actions
export const isLoadingObj = { isLoading: true };

const currentLineupsSelector = (state) => state.currentLineups.items;
const liveDraftGroupsSelector = (state) => state.liveDraftGroups;
const onlyLiveContestsSelector = (state) => state.liveContests;
const watchingSelector = (state) => state.watching;

/**
 * Helper method for calcRelevantItems, which combines arrays of objects for games and players
 * @param  {Object}   items    Former games and players
 * @param  {array}    roster   The list of new players whose games they're in we add
 * @return {object}            Combined games and players
 */
const addToRelevantItems = (roster, items = { games: [], players: [] }) => ({
  games: union(items.games, map(roster, (player) => player.gameSRID)),
  players: union(items.players, map(roster, (player) => player.srid)),
});

/**
 * Take the current contest and return two lists, one with all players by ownership, and the other the top 8 not owned
 * by me.
 * @param  {object} contest  Contest object
 * @param  {string} sport    Which sport the contest is for, used to determine default roster length
 * @return {object}          All players and top 8 players not in my lineup
 */
const calcContestPlayersOwnership = (contestLineups, draftGroup, sport, gamesTimeRemaining) => {
  const lineups = filter(contestLineups, (lineup) => lineup.roster[0] !== 0);
  const allPlayers = flatten(map(lineups, (lineup) => lineup.roster));
  const counts = countBy(allPlayers, (playerId) => playerId);

  // all
  const mappedPlayers = map(counts, (ownershipCount, playerId) => ({
    ownershipCount,
    playerId,
    ownershipPercent: parseInt(ownershipCount / allPlayers.length * 100, 10),
  }));
  const allPlayersByCounts = sortBy(mappedPlayers, (playerWithCount) => playerWithCount.ownershipCount).reverse();

  // return players with their stats
  const allWithStats = compileRosterDetails(allPlayers, draftGroup, gamesTimeRemaining, []);

  // combine counts with data
  const all = map(allPlayersByCounts,
    (playerWithCount) => merge(
      playerWithCount,
      allWithStats[playerWithCount.playerId]
    )
  );

  const allByPlayerId = {};
  forEach(mappedPlayers, (playerWithCount) => {
    allByPlayerId[playerWithCount.playerId] = playerWithCount.ownershipPercent;
  });

  return {
    all,
    allByPlayerId,
  };
};

/**
 * Loop through all contests a lineup is in and return pertinent information on them if they're live
 * @param  {integer} lineup        Lineup
 * @param  {object} lineupContests List of contests the lineup is in to loop through
 * @param  {object} contestsStats  Contest stats generated by the contest selector
 * @param  {object} liveContests   List of live contests from the server
 * @return {object}                List of contests with new stats
 */
const calcEntryContestStats = (lineup, lineupContests, liveContests) => {
  if (lineup.hasOwnProperty('id') === false) return {};

  const stats = {};

  // loop through each of the lineup's entered contests
  forEach(lineupContests, (contestId) => {
    // Make sure we have lineups.
    if (liveContests.hasOwnProperty(contestId) === false || !liveContests[contestId].hasOwnProperty('lineups')) return;

    const liveContest = liveContests[contestId];
    const entryStats = liveContest.lineups[lineup.id];

    // if stats exist (aka the lineup has started playing), then modify the given contest stats with some additional
    // information, such as our entry's rank and position, since we don't need to calculate for everyone yet
    if (entryStats && liveContest) {
      stats[contestId] = merge({}, liveContest, {
        myPercentagePosition: (entryStats.rank - 1) / liveContest.entriesCount * 100,
        myEntryRank: entryStats.rank,
        potentialWinnings: entryStats.potentialWinnings,
      });
    }
  });

  return stats;
};

/**
 * Helper method to find players that exist in both lineups a user is watching
 * @param  {object} myLineup       Lineup object
 * @param  {object} opponentLineup Lineup Object
 * @return {array}                 SRID of players in both lineups
 */
const calcPlayersInBothLineups = (myLineup, opponentLineup) =>
  intersection(
    myLineup.rosterBySRID || [],
    opponentLineup.rosterBySRID || []
  );

/**
 * Helper method to determin potential winnings for a lineup in a contest
 * @param  {integer} lineupId        Lineup ID
 * @param  {object}  contestLineups  Contest with lineups
 * @param  {integer} entriesCount    How many entries in the contest
 * @return {object}                  Potential winnings in amount and percent
 */
const calcPotentialContestStats = (lineup, contest, entriesCount = 0) => {
  const contestLineup = contest.lineups[lineup.id];
  const rank = contestLineup.rank || 0;

  return {
    potentialWinnings: contestLineup.potentialWinnings,
    rankPercent: rank / entriesCount * 100,
    rank,
  };
};

/**
 * Helper method to calculate relevant games and players
 * @param  {object} myLineup       My lineup stats
 * @param  {object} opponentLineup Opponent lineup stats
 * @return {object}                Same result as updateRelevantItems, object with games and players
 */
const calcRelevantItems = (myLineup, opponentLineup) =>
  addToRelevantItems(
    opponentLineup.rosterDetails || {},
    addToRelevantItems(myLineup.rosterDetails || {})
  );

/**
 * Shortcut method to loop through all lineup entries and their associated contests to sum potential earnings
 * @param  {object} lineups       List of lineups to find contests
 * @param  {object} contestsStats List of contests with their associated stats
 * @return {number}               Total potential earnings for the lineup
 */
export const calcTotalPotentialEarnings = (lineups, contestsStats) =>
  reduce(lineups, (sum, lineup) =>
    sum + lineup.contests.reduce((lineupSum, contestId) => {
      if (contestsStats.hasOwnProperty(contestId)) {
        const contestLineups = contestsStats[contestId].lineups || {};

        if (contestLineups.hasOwnProperty(lineup.id)) {
          return lineupSum + contestLineups[lineup.id].potentialWinnings;
        }
      }

      return lineupSum;
    }, 0),
  0);

// exported simply to test
export const watchingMyLineupSelector = createSelector([
  watchingSelector,
  myCurrentLineupsSelector,
  currentLineupsSelector,
  liveContestsSelector,
], (
  watching,
  myCurrentLineups,
  currentLineups,
  liveContests
) => {
  if (watching.myLineupId === null) return isLoadingObj;

  const lineup = myCurrentLineups[watching.myLineupId];
  // don't return anything until we have the lineup stats
  if (!lineup) return isLoadingObj;

  const originalLineup = currentLineups[lineup.id];
  // don't return anything until we have the original lineup, for contests stats
  if (!originalLineup) return isLoadingObj;

  const totalBuyin = reduce(originalLineup.contests || {}, (sum, id) => {
    if (liveContests[id]) {
      return sum + liveContests[id].buyin;
    }
    return sum;
  }, 0);

  return merge({}, lineup, {
    contestsStats: calcEntryContestStats(lineup, originalLineup.contests, liveContests),
    isLoading: false,
    potentialWinnings: calcTotalPotentialEarnings(currentLineups, liveContests),
    totalBuyin,
  });
});

// exported simply to test
export const watchingContestSelector = createSelector([
  watchingSelector,
  watchingMyLineupSelector,
  liveContestsSelector,
  onlyLiveContestsSelector,
  liveDraftGroupsSelector,
  gamesTimeRemainingSelector,
], (
  watching,
  myLineup,
  liveContests,
  onlyLiveContests,
  liveDraftGroups,
  gamesTimeRemaining
) => {
  // don't run if we don't have a contest
  if (watching.contestId === null) return {};

  const contest = liveContests[watching.contestId];
  const originalContest = onlyLiveContests[watching.contestId] || {};

  // if still loading
  if (myLineup.isLoading || !contest || contest.hasOwnProperty('lineups') === false) return isLoadingObj;

  const draftGroup = liveDraftGroups[myLineup.draftGroupId];
  const sport = watching.sport;
  const playersOwnership = calcContestPlayersOwnership(
    contest.lineups,
    draftGroup,
    sport,
    gamesTimeRemaining
  );

  // if villian watching, add to contest lineups
  if (watching.opponentLineupId === 1) {
    contest.lineups[1] = compileVillianLineup(
      watching.villainLineup,
      draftGroup,
      gamesTimeRemaining
    );
  }

  return merge(
    {},
    contest,
    calcPotentialContestStats(myLineup, contest, 1),
    {
      isLoading: false,
      lineupsUsernames: originalContest.lineupsUsernames || {},
      playersOwnership,
    }
  );
});

// exported simply to test
export const watchingOpponentLineupSelector = createSelector(
  [watchingSelector, watchingContestSelector],
  (watching, contest) => {
    if (watching.opponentLineupId === null) return {};
    if (contest.isLoading) return isLoadingObj;

    const lineup = contest.lineups[watching.opponentLineupId];
    return merge({}, lineup, calcPotentialContestStats(lineup, contest));
  }
);

export const watchingDraftGroupTimingSelector = createSelector(
  [watchingSelector, watchingMyLineupSelector, liveDraftGroupsSelector],
  (watching, myLineup, liveDraftGroups) => {
    const whenBooleans = {
      ended: false,
      started: true,
    };

    if (watching.draftGroupId && liveDraftGroups.hasOwnProperty(watching.draftGroupId)) {
      const draftGroup = liveDraftGroups[watching.draftGroupId];

      if (draftGroup.closed !== null && draftGroup.closed < dateNow()) whenBooleans.ended = true;
      if (draftGroup.start > dateNow()) whenBooleans.started = false;
    }

    return whenBooleans;
  }
);

export const relevantGamesPlayersSelector = createSelector(
  [watchingMyLineupSelector, watchingContestSelector, watchingOpponentLineupSelector, lineupsHaveRelatedInfoSelector],
  (myLineup, contest, opponentLineup, haveRelatedInfo) => {
    // nothing relevant if it's not loaded yet
    if (haveRelatedInfo === false || myLineup.isLoading || contest.isLoading || opponentLineup.isLoading) {
      return {
        isLoading: true,
        playersInBothLineups: [],
        relevantItems: {
          players: [],
          games: [],
        },
      };
    }

    return {
      isLoading: false,
      playersInBothLineups: calcPlayersInBothLineups(myLineup, opponentLineup),
      relevantItems: calcRelevantItems(myLineup, opponentLineup),
    };
  }
);
